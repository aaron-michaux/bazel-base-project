#!/bin/bash

set -euo pipefail

THIS_SCRIPT="$([ -L "$0" ] && readlink -f "$0" || echo "$0")"
SCRIPT_DIR="$(cd "$(dirname "$THIS_SCRIPT")" ; pwd -P)"

ALL_TARGETS="//example/..."
# TIDY_TARGETS="//example/..."

show_help()
{
    cat <<EOF

   Usage: $(basename $0) [Options|Rules...]* <targets>*

   Options:

      check|fix  
      show       Show resulting bazel output files

   Rules: (effects are cummulative)

      compile_commands
      static_analysis
      clang_format

   Examples:

      # Generate targets.bzl
      > $(basename $0) clang_format check //src/... //config/...

      # Generate compile commands
      > $(basename $0) compile_commands //src/...

EOF
}

# -- Parse the command line

for ARG in "$@" ; do
    [ "$ARG" = "-h" ] || [ "$ARG" = "--help" ] && show_help && exit 0
done

RULES=""
CHECK="check"
BUILDIFIER_VERBOSE="False"
SHOW="False"
while (( $# > 0 )) ; do
    ARG="$1"
    [ "$ARG" = "check" ] || [ "$ARG" = "fix" ] && CHECK="$ARG" && shift && continue
    [ "$ARG" = "show"             ] && SHOW="True"    && shift && continue
    [ "$ARG" = "compile_commands" ] && RULES+=" $ARG" && shift && continue
    [ "$ARG" = "static_analysis"  ] && RULES+=" $ARG" && shift && continue
    [ "$ARG" = "clang_format"     ] && RULES+=" $ARG" && shift && continue
    break
done

if [ "$RULES" = "" ] ; then
    echo "No rule was specified, aboritng" 1>&2 && exit 1    
fi

workspace_dir()
{
    while true ; do    
        [ -f "WORKSPACE" ] && pwd -P && return 0
        local D="$(pwd)"
        cd ..
        [ "$D" = "$(pwd)" ] && echo "Could not find WORKSPACE file, aborting" 1>&2 && exit 1
    done
}

WORKSPACE_DIR="$(workspace_dir)"
TMPD="$SCRIPT_DIR/generated"
rm -rf "$TMPD"
mkdir -p "$TMPD"
trap cleanup EXIT
cleanup()
{
    rm -rf "$TMPD"
}

build_template()
{
    cat <<EOF
load("@initialize_toolchain//:defs.bzl", "compile_commands", "clang_format", "clang_tidy")

# Autogenerated
load(":targets.bzl", "TARGETS")

FILE_FILTERS = ["bazel-"]

compile_commands(
    name = "compile_commands",
    targets = TARGETS,
    indent = True,
    testonly = True,
    tags = ["manual"],
)

clang_tidy(
    name = "static_analysis",
    clang_tidy = "@initialize_toolchain//:clang_tidy_bin",
    config_file = "//:clang_tidy_config",
    targets = TARGETS,
    filter_files = FILE_FILTERS,
    filter_tags = ["no_static_analysis"],
    testonly = True,
    tags = ["manual"],
)

clang_format(
    name = "clang_format_$CHECK",
    clang_format = "@initialize_toolchain//:clang_format_bin",
    config_file = "//:clang_format_config",
    mode = "$CHECK",                            # ["check", "fix"]
    targets = TARGETS,
    filter_files = FILE_FILTERS,
    testonly = True,
    tags = ["manual"],
)

EOF
}

query_targets()
{
    cd "$WORKSPACE_DIR"
    for QUERY in "$@" ; do
        if ! bazel query "$QUERY" 2>"$TMPD/stderr" ; then
            echo "ERROR executing query:" 1>&2
            echo 1>&2
            echo "   bazel query $QUERY" 1>&2
            echo 1>&2
            cat "$TMPD/stderr" 1>&2
            exit 1
        fi
    done | sort | uniq 
}

target_list()
{
    query_targets "$@" | sed 's,^,   ",' | sed 's/$/",/' > "$TMPD/list"
    if [ "$(cat $TMPD/list)" = "" ] ; then
        echo "[]"
    else
        printf "[\n%s\n]" "$(cat "$TMPD/list")"
    fi   
}

cat > "$TMPD/targets.bzl" <<EOF
"""
This file is auto-generated by $(basename $0)
"""

TARGETS = $(target_list "$@")

EOF

# Just write over 'targets.bzl'
build_template > "$TMPD/BUILD.bazel"

# Now run bazel
cd "$WORKSPACE_DIR"

OUTBASE="$($WORKSPACE_DIR/tools/print_output_base.sh)"

for RULE in $RULES ; do
    EXTRA_ARGS=""
    ACTION="build"
    STARTUP="--nosystem_rc --nohome_rc"
    
    if [ "$RULE" = "clang_format" ] || [ "$RULE" = "python_format" ] ; then
        [ "$SHOW" = "True" ] && SHOW_RESULT="" || SHOW_RESULT=" --show_result=0"
        STARTUP+=" --output_base=${OUTBASE}/dbg_llvm"
        EXTRA_ARGS+=" --config=llvm${SHOW_RESULT} --keep_going"
        EXTRA_ARGS+=" --spawn_strategy=standalone" || true        
        RULE+="_${CHECK}"
        
    elif [ "$RULE" = "static_analysis" ] ; then
        STARTUP+=" --output_base=${OUTBASE}/static_analysis"
        EXTRA_ARGS+=" --config=static_analysis --verbose_failures --show_result=0"

    elif [ "$RULE" = "compile_commands" ] ; then
        STARTUP+=" --output_base=${OUTBASE}/compdb"
        EXTRA_ARGS+=" --config=compdb"
        
    fi
    
    COMMAND="bazel $STARTUP $ACTION${EXTRA_ARGS} //tools/lint/$(basename "$TMPD"):$RULE"
    echo
    echo "   $COMMAND"
    echo
    $COMMAND

    if [ "$RULE" = "compile_commands" ] ; then
        # There's no sane way for the compile-commands rule to know the WORKSPACE path a priori, so we output '"directory": "."' from bazel, and then patch in the WORKSPACE directory at the end.
        OUT_FILE="$WORKSPACE_DIR/bazel-bin/tools/lint/$(basename "$TMPD")/compile_commands.json"
        if [ -f "$OUT_FILE" ] ; then
            cat "$OUT_FILE" | sed "s|\"directory\": \".\"|\"directory\": \"$WORKSPACE_DIR\"|" > "$WORKSPACE_DIR/compile_commands.json"
        fi
    fi
done


